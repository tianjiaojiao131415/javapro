package Days_0212;/** * Created by admin on 2020/2/12. * 多线程 * 进程：正在运行的程序 * 线程：线程是进程的一个执行过程 也就是说一个进程可以包含多个线程（至少含有一个线程） * * 如何创建多线程 *      1、继承Thread类 *      2、实现Runnable接口 *      3、线程池 * *    如果用 继承Thread类或者实现接口Runnable接口的方式，那么必须要重写run方法 *    当执行的时候，调用run方法并非是以线程的方式启动，知识调用了一个方法， *    要用start方法进行启动线程，启动该线程，该线程的入口是run方法 *    Thread里面有一个方法，sleep（传一个毫秒值）表示暂时放弃对cpu的抢占 *    Thread.sleep(500); 传一个毫秒值，500毫秒内放弃对cpu的抢占，500毫秒之后会开始对cpu的抢占，但是不一定可以强到 *    Thread.currentThread() 获取当前的线程 *    Thread.currentThread().getName() 获取当前线程的名字 * *    2、实现Runnable接口 *    需要重写run方法 *    没有start方法，需要再创建一个线程Thread对象   Thread thread = new Thread(myThrea2); */import java.util.ArrayList;import java.util.List;/** * lambad  表达式 * 匿名内部类的一个变体写法 * 匿名内部类 *      接口和抽象类 不能被实列化  从来没说过 接口和抽象类不能new *      new 接口 或者 抽象类 就是匿名内部类 * * */public class XianCheng {    public static List list = new ArrayList();   // public static int a=0;    public static void main(String[] args) {       /* MyThread myThread = new MyThread();        //要用start方法进行启动线程，启动该线程，该线程的入口是run方法        //两个线程同时抢占cpu        myThread.start();        MyThread myThread1 = new MyThread();        myThread1.start();*/     /*  MyThrea2 myThrea2 = new MyThrea2();       Thread thread = new Thread(myThrea2);       thread.start();*/     //匿名内部类的实现方式,在代码没有复用性的情况下，可以使用该方法 /*    Thread thread = new Thread(()-> {         for (int i = 0; i <10 ; i++) {             try {                 Thread.sleep(500);             } catch (InterruptedException e) {                 e.printStackTrace();             }             System.out.println(Thread.currentThread().getName()+"正在运行的线程"+i);         }     });     thread.start();*/        for (int i = 0; i < 5000; i++) {            Thread thread = new Thread(()->{                list.add(1);            });            thread.start();        }        System.out.println(list.size());   /*  MyInteface myjia = new Myjia();     MyInteface myjian = new Myjian();     MyInteface myCheng = new MyCheng();     MyInteface myChu = new MyChu();*/   //匿名内部类   /*     System.out.println(method(12, 6, new MyInteface() {            @Override            public int method(int a, int b) {                return a+b;            }        }));*//*        System.out.println(method(12, 6, (a,b)-> {//匿名内部类的简写          return a+b;        }));*/        }    public static int method(int a,int b ,MyInteface myInteface){         return myInteface.method(a,b);    }}