package com.neuedu.test;

/**
 * Created by admin on 2020/2/9.
 * 构造方法
 *     1、构造方法一旦被调用 则会返回一个对象
 *     2、为私有属性赋值
 *          访问修饰符  方法名【方法名必须和类名一样】（参数列表）{
 *              代码    不必写返回值
 *          }
 *   如果不写  则默认生成一个没有参数的构造方法
 *   如果写了  不会生成
 */


/**
 *    继承   两个类之间的行为
 *        明确了两个类之间的父子关系
 *        子类可以拿到父类的属性和方法
 *
 *   实现方法   在子类中   定义类之后    加 extends 父类名
 *
 *   重写（覆盖）
 *      子类中定义了和父类   方法名 返回值【特殊情况下可以不同】 参数列表完全相同的方法
 *
 *      重写 override 和 重载 overlode  有什么区别
 *      1、重载是一个类的事    重写是具有父子关系两个类的事
 *      2、重载是一个类下 定义了 相同的方法名 不同的参数列表
 *      3、重写是 子类中定义了和父类 方法名 返回值 参数列表完全相同的方法
 * */
/**
 *      抽象方法  --- 只有方法的定义  没有方法的代码
 *          规定了子类必须要重写的方法（不重写报错）
 *          定义方法 父类的方法  加关键词  abstract
 *          一旦类中有了抽象方法  那么该类就必须定义为抽象类
 *          抽象类的定义方式 类加上 abstract
 *          抽象类不能实列化（不能创造对象）
 *          抽象类能有构造方法  到那时不能实列化
 *          构造方法是继承用的（为子类准备的）
 *
 *
 *      抽象类中 可以没有抽象方法
 *      如果有了抽象方法  就必须是抽象类
 * */
/**
 *   this  代表当前对象
 *   super 代表调用父类
 *
 *   super（）  代表调用父类的无参构造
 *   super（）  无论你写不写都在
 *   如果写 系统不会帮你生成  如果不写  系统会自动生成一个super（）
 *   如果写 要注意 super（）方法  必须在构造方法的第一句上
 *
 *
 *      多态-----建立在继承的基础之上
 *      赋值多态
 *          父类引用指向子类对象  子类的对象可以给父类的引用赋值
 *      传参多态
 *          当一个方法的参数类型定义为父类的时候  所有子类都可以传参
 *
 *
 *
 *      接口
 *          接口在jdk1.8之前 只能有抽象方法  不能有非抽象方法
 *          接口中  没有属性和构造方法
 *
 *
 *
 *     继承父类   extends  父类名
 *     实现（继承）   接口 implements  接口名
 *
 *     传参多态
 *         参数如果是父类  那么所有子类的对象都可以传递
 *
 * */
/**
 * 集合
 *    List
 *        1、ArrayList
 *        2、Vector
 *        3、LinkedList
 *        （三个的用法是一样的）
 *        ArrayList和Vector之间的区别
 *        ArrayList  非线程安全    Vector  线程安全
 *        ArrayList和LinkedList之间的区别
 *        ArrayList的底层是数组    LinkedList的底层是列表
 *    Set
 *    Map
 *
 *
 * */
public class Method {
    public static void main(String[] args) {
        //赋值多态
      Teacher wang = new Wang();

      //传参多态
      method(wang);

    }
    public static void method(Teacher teacher){
        System.out.println("上课");
    }
}
