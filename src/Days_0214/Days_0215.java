package Days_0214;import java.util.*;/** * Created by admin on 2020/2/15. */public class Days_0215 {    public static void main(String[] args) {        List list = new ArrayList();        //list 可以放重复的元素     /*   list.add(1);        list.add(1);        for (int i = 0; i <list.size() ; i++) {            System.out.println(list.get(i));            输出            1            1        }*/     /*   Vector vector= new Vector();        vector.add(1);        vector.add(1);        for (int i = 0; i <vector.size() ; i++) {            System.out.println(vector.get(i));        }*/     //Set不可以放重复的元素 ，不能通过下标来取值，没有get方法       // Set set = new HashSet();//HashSet是没有任何我顺序的       // Set set = new TreeSet();//按照给的内容进行一个自然排序（数字从小到大）        Set set = new LinkedHashSet();//按照添加的内容进行排序        set.add(1);        set.add(100);        set.add(200);        set.add(30);        set.add(20);        set.add(100);        set.add(1);        for (Object obj:set){            System.out.println(obj);            //输出的值为1，100，20，200，30 输出的值没有任何顺序        }        /**         * 包装类         * 使用泛型规范了数据类型         *          在类中定义了属性时，都要用泛型，如果不用泛型，而用基本数据类型，         *          那么取值的时候，就分不清楚，是否给对象传值了         * */        Person person = new Person();        System.out.println(person.getAge());        //0  此时输出的是int的默认值，但是会导致无法区分是否传值        //null 是使用泛型后的结果，这样就可以确定有没有传值        //包装类的比较，在-128--127之间可以==号进行比较（有一个8位缓存，-128--127之间都从缓存里面取值），        // 128以后要用a.intValue()==b.intValue(        /*Integer a=127;        Integer b=127;        System.out.println(a==b);//true*/       /* Integer a=128;        Integer b=128;        System.out.println(a==b);//false*/        Integer a=128;        Integer b=128;        System.out.println(a.intValue()==b.intValue());//true        //HashMap是传入（k,v） 非线程安全        // 通过 k 来取值  map.get("1")        // .put 方法来传值        // 一旦传输相同的k 值，就会覆盖原来的 k         HashMap<String,String> map = new HashMap<>();         map.put("1","张三");         map.put("2","李四");        map.put("2","王二");       // System.out.println(map.get("1"));//张三       //  System.out.println(map.get("2"));//王二   一旦传输相同的k 值，就会覆盖原来的 k        //可以通过循环key 来进行取值        Set<String> keys= map.keySet();        for (String key :keys){            System.out.println(map.get(key));        }    }}