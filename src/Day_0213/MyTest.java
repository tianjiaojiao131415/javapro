package Day_0213;import java.awt.*;import java.util.ArrayList;import java.util.concurrent.CountDownLatch;import java.util.concurrent.Semaphore;/** * Created by admin on 2020/2/13. */public class MyTest {   // public  static  int a =0;   // public static ArrayList list = new ArrayList();    public static StringBuffer sb = new StringBuffer();    public  static  Object obj = new Object();    //main下的线程名就叫main，main方法本来就是一条线程    public static void main(String[] args) {        //两个线程同时执行时，会出现抢占cpu的问题，        // 就像卖票系统，两个人各有40张票，各卖各的       /* MyThread myThread1 = new MyThread();        MyThread myThread2 = new MyThread();        myThread1.start();        myThread2.start();*/       //继承Runnable需要new一个Thread        // 继承Runnable可以实现两个人从80张票里卖票，但是也出现了线程抢占的问题      /* Runnable myThread3=new MyRunnable();       Thread t1 = new Thread(myThread3);       Thread t2 = new Thread(myThread3);       t1.start();       t2.start();*/    /*  MyRunnable runnable = new MyRunnable();      Thread t3 = new Thread(()->{          runnable.add();      });      Thread t4 = new Thread(()->{         runnable.del();      });      t3.start();      t4.start();*/        //此时i循环5000次，得到的结果是不唯一的        CountDownLatch countDownLatch = new CountDownLatch(5000);        Semaphore semaphore = new Semaphore(1);//创建一个信号量对象，传信号量（当传入一个信号量时，相当于                                                            //synchronized ）        for (int i = 0; i <5000 ; i++) {            Thread thread = new Thread(()->{                try {                  // semaphore.acquire();//获取一个信号量                    //a++;                  //  list.add("1");                    sb.append("1");                    countDownLatch.countDown();                  //  semaphore.release();//释放一个信号量                } catch (Exception e) {                    e.printStackTrace();                }            });            thread.start();        }        /**         * 要解决的第一个问题 必须让 输出a 在5000次循环结束之后         * 方法：闭锁         * CountDownLatch 在创建的时候，就已经加上了锁的数量         *     CountDownLatch 对象名 = new CountDownLatch（锁的数量）         *         *     方法 await（） 代表阻塞 等待 全部的锁解开为止 ，当全部的锁都解开后 await（） 则放行         *         *     countdown（） 没调用一次，表示解一把锁         *  以上的方法还是不能解决问题         *         *  还需要再定义一个锁旗标         *         * */        try {            countDownLatch.await();        } catch (InterruptedException e) {            e.printStackTrace();        }      //  System.out.println(a);      //  System.out.println(list.size());//非线程安全，需要加上信号量或者是synchronized        System.out.println(sb.length());//线程安全，不需要加上信号量或者是synchronized    }}